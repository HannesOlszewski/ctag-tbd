#include "ctagSoundProcessorBBDelay.hpp"
#include "esp_heap_caps.h"
#include "stmlib/stmlib.h"
#include "stmlib/dsp/dsp.h"
#include "helpers/ctagFastMath.hpp"

using namespace CTAG::SP;

// on delays https://www.kvraudio.com/forum/viewtopic.php?t=265070
// https://www.kvraudio.com/forum/viewtopic.php?t=382266


void ctagSoundProcessorBBDelay::Process(const ProcessData &data) {
	float fDelayTime = time_ms; if(cv_time_ms != -1) fDelayTime = fabsf(data.cv[cv_time_ms]);
	// convert fDelayTime to taps
	float ofs = fDelayTime * 44.1f;

	MK_FLT_PAR_ABS(fFeedback, feedback, 4095.f, 1.f)
	MK_FLT_PAR_ABS(fTone, tone, 4095.f, 1.f)
	MK_FLT_PAR_ABS(fMix, mix, 4095.f, 1.f)

	typedef E::Reserve<65535> Memory;
	E::DelayLine<Memory, 0> line;
	E::Context c;

	// simple echo effect
	for(int i=0;i<32;i++){
		if(delayOffset != ofs){
			delayOffset = ONE_POLE(delayOffset, ofs, 0.00001f);
		}
		engine.Start(&c);
		const float in = data.buf[i*2];
		float out;
		c.Interpolate(line, delayOffset, .5f);
		c.Write(out);
		c.Load(in);
		c.Read(out, fFeedback);
		c.Write(line,0.f);

		// mix in and out
		data.buf[i*2] = (1.f - fMix) * in + fMix * out;
		data.buf[i*2 + 1] = data.buf[i*2];
	}


}
/*
void ctagSoundProcessorBBDelay::Process(const ProcessData &data) {
	float fDelayTime = time_ms; if(cv_time_ms != -1) fDelayTime = fabsf(data.cv[cv_time_ms]);
	MK_FLT_PAR_ABS(fFeedback, feedback, 4095.f, 1.f)
	MK_FLT_PAR_ABS(fTone, tone, 4095.f, 1.f)
	MK_FLT_PAR_ABS(fMix, mix, 4095.f, 1.f)


	float ofs = fDelayTime * 44.1f;
	for(int i=0; i<32; i++){
		// Calculate the delay offset in samples
		if(delayOffset != ofs){
			delayOffset = ONE_POLE(delayOffset, ofs, 0.0001f);
			//delayOffset = ofs;
			readPos = static_cast<float>(writeIndex) - delayOffset;
			if(readPos < 0.f) readPos += 44100.f;
			if(readPos >= 44100.f) readPos -= 44100.f;
		}

		float inputSample = data.buf[i*2];
		float outputSample = 0.0f;

		MAKE_INTEGRAL_FRACTIONAL(readPos);
		outputSample = HELPERS::InterpolateWaveLinearWrap(delayBuffer, readPos, 44100);
		//outputSample = HELPERS::InterpolateWaveHermiteWrap(delayBuffer, readPos, 44100);
		readPos += 1.f;
		readPos > 44100.f ? readPos -= 44100.f : readPos;


		// Write the input sample to the delay buffer
		delayBuffer[writeIndex] = inputSample + outputSample * fFeedback * fFeedback;
		writeIndex = (writeIndex + 1) % 44100;

		// Mix the dry (input) and wet (delayed) signal
		data.buf[i*2] = (1.0f - fMix) * inputSample + fMix * outputSample;
		data.buf[i*2 + 1] = data.buf[i*2];
	}

}
*/
void ctagSoundProcessorBBDelay::Init(std::size_t blockSize, void *blockPtr) {
    // construct internal data model
    knowYourself();
    model = std::make_unique<ctagSPDataModel>(id, isStereo);
    LoadPreset(0);

    // check if blockMem is large enough
    // blockMem is used just like larger blocks of heap memory
    // assert(blockSize >= memLen);
    // if memory larger than blockMem is needed, use heap_caps_malloc() instead with MALLOC_CAPS_SPIRAM

	delayBuffer = static_cast<float*>(heap_caps_malloc(44100 * sizeof(float), MALLOC_CAP_SPIRAM));
	assert(delayBuffer != nullptr);
	engine.Init(delayBuffer);

	sineSource.SetSampleRate(44100.f);
	sineSource.SetFrequency(1000.f);
}

// no ctor, use Init() instead, is called from factory after successful creation
// dtor
ctagSoundProcessorBBDelay::~ctagSoundProcessorBBDelay() {
    // no explicit freeing for blockMem needed, done by ctagSPAllocator
    // explicit free is only needed when using heap_caps_malloc() with MALLOC_CAPS_SPIRAM

	heap_caps_free(delayBuffer);
}

void ctagSoundProcessorBBDelay::knowYourself(){
    // autogenerated code here
    // sectionCpp0
	pMapPar.emplace("time_ms", [&](const int val){ time_ms = val;});
	pMapCv.emplace("time_ms", [&](const int val){ cv_time_ms = val;});
	pMapPar.emplace("feedback", [&](const int val){ feedback = val;});
	pMapCv.emplace("feedback", [&](const int val){ cv_feedback = val;});
	pMapPar.emplace("tone", [&](const int val){ tone = val;});
	pMapCv.emplace("tone", [&](const int val){ cv_tone = val;});
	pMapPar.emplace("mix", [&](const int val){ mix = val;});
	pMapCv.emplace("mix", [&](const int val){ cv_mix = val;});
	isStereo = false;
	id = "BBDelay";
	// sectionCpp0
}