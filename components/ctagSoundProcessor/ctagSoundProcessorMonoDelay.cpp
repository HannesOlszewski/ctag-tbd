#include "ctagSoundProcessorMonoDelay.hpp"
#include "esp_heap_caps.h"
#include "stmlib/stmlib.h"
#include "stmlib/dsp/dsp.h"
#include "helpers/ctagFastMath.hpp"

using namespace CTAG::SP;

// on delays https://www.kvraudio.com/forum/viewtopic.php?t=265070
// https://www.kvraudio.com/forum/viewtopic.php?t=382266

/* mifx engine version
void ctagSoundProcessorMonoDelay::Process(const ProcessData &data) {
	float fDelayTime = time_ms; if(cv_time_ms != -1) fDelayTime = fabsf(data.cv[cv_time_ms]);
	// convert fDelayTime to taps
	float ofs = fDelayTime * 44.1f;

	MK_FLT_PAR_ABS(fFeedback, feedback, 4095.f, 1.f)
	MK_FLT_PAR_ABS(fTone, tone, 4095.f, 1.f)
	MK_FLT_PAR_ABS(fMix, mix, 4095.f, 1.f)

	typedef E::Reserve<65535> Memory;
	E::DelayLine<Memory, 0> line;
	E::Context c;

	// simple echo effect
	for(int i=0;i<32;i++){
		if(delayOffset != ofs){
			delayOffset = ONE_POLE(delayOffset, ofs, 0.00001f);
		}
		engine.Start(&c);
		const float in = data.buf[i*2];
		float out;
		c.Interpolate(line, delayOffset, .5f);
		c.Write(out);
		c.Load(in);
		c.Read(out, fFeedback);
		c.Write(line,0.f);

		// mix in and out
		data.buf[i*2] = (1.f - fMix) * in + fMix * out;
		data.buf[i*2 + 1] = data.buf[i*2];
	}


}
*/

void ctagSoundProcessorMonoDelay::Process(const ProcessData &data) {
	fDelayTime = time_ms; if(cv_time_ms != -1) fDelayTime = fabsf(data.cv[cv_time_ms]) * 2.f;
	MK_FLT_PAR_ABS(fFeedback, feedback, 4095.f, 1.05f)
	MK_FLT_PAR_ABS(fTone, tone, 4095.f, 1.f)
	MK_FLT_PAR_ABS(fMix, mix, 4095.f, 1.f)
	MK_BOOL_PAR(bTapeDigital, tape_digital)
	MK_BOOL_PAR(bFreeze, freeze)
	bool bSync = sync;
	bool bSyncTrig {false};
	if(trig_sync != -1) bSyncTrig = data.trig[trig_sync] == 1 ? false : true;
	fTime += 44100.f / 32.f;
	if(bSyncTrig != pre_sync){
		pre_sync = bSyncTrig;
		if(bSyncTrig){

			// get esp time in ms
			// calculate the time difference between the last sync and now
			float diff = fabsf(fTime - fSyncTimeStamp);
			fSyncTimeStamp = fTime;
			fTime = 0.f;
			if(bSync){
				fDelayTime = diff;
				printf("fDelayTime %f\n", fDelayTime);
			}
		}
	}

	CONSTRAIN(fDelayTime, 0.0001, 2000.f)
	float ofs = fDelayTime * 44.1f;
	for(int i=0; i<32; i++){
		// Calculate the delay offset in samples
		if(delayOffset != ofs){
			if(bTapeDigital){
				delayOffset = ofs;
			} else {
				delayOffset = ONE_POLE(delayOffset, ofs, 0.0001f);
			}
			readPos = static_cast<float>(writeIndex) - delayOffset;
			if(readPos < 0.f) readPos += 88200.f;
			if(readPos >= 88200.f) readPos -= 88200.f;
		}

		float inputSample = data.buf[i*2];
		float outputSample = 0.0f;

		MAKE_INTEGRAL_FRACTIONAL(readPos);
		outputSample = HELPERS::InterpolateWaveLinearWrap(delayBuffer, readPos, 88200);
		//outputSample = HELPERS::InterpolateWaveHermiteWrap(delayBuffer, readPos, 44100);
		readPos += 1.f;
		readPos > 88200.f ? readPos -= 88200.f : readPos;


		// Write the input sample to the delay buffer
		if(!bFreeze)
			delayBuffer[writeIndex] = inputSample + outputSample * fFeedback * fFeedback;
		else
			delayBuffer[writeIndex] = outputSample;
		writeIndex = (writeIndex + 1) % 88200;

		// Mix the dry (input) and wet (delayed) signal
		data.buf[i*2] = (1.0f - fMix) * inputSample + fMix * outputSample;
		data.buf[i*2 + 1] = data.buf[i*2];
	}

}

void ctagSoundProcessorMonoDelay::Init(std::size_t blockSize, void *blockPtr) {
    // construct internal data model
    knowYourself();
    model = std::make_unique<ctagSPDataModel>(id, isStereo);
    LoadPreset(0);

    // check if blockMem is large enough
    // blockMem is used just like larger blocks of heap memory
    // assert(blockSize >= memLen);
    // if memory larger than blockMem is needed, use heap_caps_malloc() instead with MALLOC_CAPS_SPIRAM

	delayBuffer = static_cast<float*>(heap_caps_malloc(88200 * sizeof(float), MALLOC_CAP_SPIRAM));
	assert(delayBuffer != nullptr);
	// engine.Init(delayBuffer);

}

// no ctor, use Init() instead, is called from factory after successful creation
// dtor
ctagSoundProcessorMonoDelay::~ctagSoundProcessorMonoDelay() {
    // no explicit freeing for blockMem needed, done by ctagSPAllocator
    // explicit free is only needed when using heap_caps_malloc() with MALLOC_CAPS_SPIRAM

	heap_caps_free(delayBuffer);
}

void ctagSoundProcessorMonoDelay::knowYourself(){
    // autogenerated code here
    // sectionCpp0
	pMapPar.emplace("time_ms", [&](const int val){ time_ms = val;});
	pMapCv.emplace("time_ms", [&](const int val){ cv_time_ms = val;});
	pMapPar.emplace("sync", [&](const int val){ sync = val;});
	pMapTrig.emplace("sync", [&](const int val){ trig_sync = val;});
	pMapPar.emplace("freeze", [&](const int val){ freeze = val;});
	pMapTrig.emplace("freeze", [&](const int val){ trig_freeze = val;});
	pMapPar.emplace("tape_digital", [&](const int val){ tape_digital = val;});
	pMapTrig.emplace("tape_digital", [&](const int val){ trig_tape_digital = val;});
	pMapPar.emplace("feedback", [&](const int val){ feedback = val;});
	pMapCv.emplace("feedback", [&](const int val){ cv_feedback = val;});
	pMapPar.emplace("tone", [&](const int val){ tone = val;});
	pMapCv.emplace("tone", [&](const int val){ cv_tone = val;});
	pMapPar.emplace("mix", [&](const int val){ mix = val;});
	pMapCv.emplace("mix", [&](const int val){ cv_mix = val;});
	isStereo = false;
	id = "MonoDelay";
	// sectionCpp0
}